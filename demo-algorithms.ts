#!/usr/bin/env tsx
/**
 * Demo script to run all chip design algorithms
 *
 * Run with: npx tsx demo-algorithms.ts
 */

import { runPlacement } from './src/lib/algorithms/placement';
import { runRouting } from './src/lib/algorithms/routing';
import { runFloorplanning } from './src/lib/algorithms/floorplanning';
import { runSynthesis } from './src/lib/algorithms/synthesis';
import { runTiming } from './src/lib/algorithms/timing';
import { runPower } from './src/lib/algorithms/power';
import {
  Cell,
  Net,
  PlacementAlgorithm,
  RoutingAlgorithm,
  FloorplanningAlgorithm,
  SynthesisAlgorithm,
  TimingAlgorithm,
  PowerAlgorithm,
} from './src/types/algorithms';

// Helper to create test cells
function createTestCells(): Cell[] {
  return [
    {
      id: 'cell1',
      name: 'AND Gate',
      width: 10,
      height: 10,
      pins: [
        { id: 'pin1', name: 'A', position: { x: 0, y: 5 }, direction: 'input' },
        { id: 'pin2', name: 'B', position: { x: 0, y: 7 }, direction: 'input' },
        { id: 'pin3', name: 'Y', position: { x: 10, y: 5 }, direction: 'output' },
      ],
      type: 'standard',
    },
    {
      id: 'cell2',
      name: 'OR Gate',
      width: 10,
      height: 10,
      pins: [
        { id: 'pin4', name: 'A', position: { x: 0, y: 5 }, direction: 'input' },
        { id: 'pin5', name: 'B', position: { x: 0, y: 7 }, direction: 'input' },
        { id: 'pin6', name: 'Y', position: { x: 10, y: 5 }, direction: 'output' },
      ],
      type: 'standard',
    },
    {
      id: 'cell3',
      name: 'NOT Gate',
      width: 8,
      height: 8,
      pins: [
        { id: 'pin7', name: 'A', position: { x: 0, y: 4 }, direction: 'input' },
        { id: 'pin8', name: 'Y', position: { x: 8, y: 4 }, direction: 'output' },
      ],
      type: 'standard',
    },
    {
      id: 'cell4',
      name: 'XOR Gate',
      width: 12,
      height: 10,
      pins: [
        { id: 'pin9', name: 'A', position: { x: 0, y: 5 }, direction: 'input' },
        { id: 'pin10', name: 'B', position: { x: 0, y: 7 }, direction: 'input' },
        { id: 'pin11', name: 'Y', position: { x: 12, y: 5 }, direction: 'output' },
      ],
      type: 'standard',
    },
  ];
}

function createTestNets(): Net[] {
  return [
    { id: 'net1', name: 'Net 1', pins: ['pin3', 'pin4'], weight: 1 },
    { id: 'net2', name: 'Net 2', pins: ['pin6', 'pin7'], weight: 1.5 },
    { id: 'net3', name: 'Net 3', pins: ['pin8', 'pin9'], weight: 1 },
  ];
}

console.log('üî∑ CHIP DESIGN ALGORITHMS DEMO\n');
console.log('=' .repeat(60));

// 1. PLACEMENT ALGORITHMS
console.log('\nüìç 1. PLACEMENT ALGORITHMS');
console.log('-'.repeat(60));

const placementParams = {
  algorithm: PlacementAlgorithm.SIMULATED_ANNEALING,
  chipWidth: 100,
  chipHeight: 100,
  cells: createTestCells(),
  nets: createTestNets(),
  iterations: 200,
  temperature: 1000,
  coolingRate: 0.95,
};

console.log('\nüî• Running Simulated Annealing Placement...');
const saResult = runPlacement(placementParams);
console.log(`‚úÖ Success: ${saResult.success}`);
console.log(`üìä Total Wirelength: ${saResult.totalWirelength.toFixed(2)}`);
console.log(`üîÑ Iterations: ${saResult.iterations}`);
console.log(`‚è±Ô∏è  Runtime: ${saResult.runtime.toFixed(2)}ms`);
console.log(`üìê Overlap: ${saResult.overlap.toFixed(2)}`);

console.log('\nüß¨ Running Genetic Algorithm Placement...');
const gaResult = runPlacement({
  ...placementParams,
  algorithm: PlacementAlgorithm.GENETIC,
  populationSize: 30,
  mutationRate: 0.1,
  iterations: 100,
});
console.log(`‚úÖ Success: ${gaResult.success}`);
console.log(`üìä Total Wirelength: ${gaResult.totalWirelength.toFixed(2)}`);
console.log(`‚è±Ô∏è  Runtime: ${gaResult.runtime.toFixed(2)}ms`);

console.log('\n‚ö° Running Force-Directed Placement...');
const fdResult = runPlacement({
  ...placementParams,
  algorithm: PlacementAlgorithm.FORCE_DIRECTED,
  iterations: 300,
});
console.log(`‚úÖ Success: ${fdResult.success}`);
console.log(`üìä Total Wirelength: ${fdResult.totalWirelength.toFixed(2)}`);
console.log(`‚è±Ô∏è  Runtime: ${fdResult.runtime.toFixed(2)}ms`);

// 2. ROUTING ALGORITHMS
console.log('\n\nüõ£Ô∏è  2. ROUTING ALGORITHMS');
console.log('-'.repeat(60));

const cellsWithPositions = saResult.cells; // Use placed cells

const routingParams = {
  algorithm: RoutingAlgorithm.MAZE_ROUTING,
  chipWidth: 100,
  chipHeight: 100,
  cells: cellsWithPositions,
  nets: createTestNets(),
  layers: 2,
  gridSize: 5,
};

console.log('\nüåÄ Running Maze Routing (Lee\'s Algorithm)...');
const mazeResult = runRouting(routingParams);
console.log(`‚úÖ Success: ${mazeResult.success}`);
console.log(`üìè Total Wirelength: ${mazeResult.totalWirelength}`);
console.log(`üîó Wires Created: ${mazeResult.wires.length}`);
console.log(`üîå Via Count: ${mazeResult.viaCount}`);
console.log(`‚è±Ô∏è  Runtime: ${mazeResult.runtime.toFixed(2)}ms`);

console.log('\n‚≠ê Running A* Routing...');
const astarResult = runRouting({
  ...routingParams,
  algorithm: RoutingAlgorithm.A_STAR,
});
console.log(`‚úÖ Success: ${astarResult.success}`);
console.log(`üìè Total Wirelength: ${astarResult.totalWirelength}`);
console.log(`üîó Wires Created: ${astarResult.wires.length}`);
console.log(`‚è±Ô∏è  Runtime: ${astarResult.runtime.toFixed(2)}ms`);

console.log('\nüåç Running Global Routing...');
const globalResult = runRouting({
  ...routingParams,
  algorithm: RoutingAlgorithm.GLOBAL_ROUTING,
  gridSize: 25,
});
console.log(`‚úÖ Success: ${globalResult.success}`);
console.log(`üìè Total Wirelength: ${globalResult.totalWirelength}`);
console.log(`üîó Wires Created: ${globalResult.wires.length}`);
console.log(`‚è±Ô∏è  Runtime: ${globalResult.runtime.toFixed(2)}ms`);

// 3. FLOORPLANNING ALGORITHMS
console.log('\n\nüèóÔ∏è  3. FLOORPLANNING ALGORITHMS');
console.log('-'.repeat(60));

const blocks = createTestCells();

console.log('\nüå≤ Running Slicing Tree Floorplanning...');
const slicingResult = runFloorplanning({
  algorithm: FloorplanningAlgorithm.SLICING_TREE,
  chipWidth: 150,
  chipHeight: 150,
  blocks,
});
console.log(`‚úÖ Success: ${slicingResult.success}`);
console.log(`üìê Area: ${slicingResult.area}`);
console.log(`üìä Utilization: ${(slicingResult.utilization * 100).toFixed(2)}%`);
console.log(`üíÄ Dead Space: ${slicingResult.deadSpace.toFixed(2)}`);
console.log(`‚è±Ô∏è  Runtime: ${slicingResult.runtime.toFixed(2)}ms`);

console.log('\nüî¢ Running Sequence Pair Floorplanning...');
const seqPairResult = runFloorplanning({
  algorithm: FloorplanningAlgorithm.SEQUENCE_PAIR,
  chipWidth: 150,
  chipHeight: 150,
  blocks: createTestCells(),
});
console.log(`‚úÖ Success: ${seqPairResult.success}`);
console.log(`üìê Area: ${seqPairResult.area}`);
console.log(`üìä Utilization: ${(seqPairResult.utilization * 100).toFixed(2)}%`);
console.log(`‚è±Ô∏è  Runtime: ${seqPairResult.runtime.toFixed(2)}ms`);

// 4. SYNTHESIS ALGORITHMS
console.log('\n\n‚öôÔ∏è  4. SYNTHESIS ALGORITHMS');
console.log('-'.repeat(60));

const netlist = `
module simple_circuit (
  input a, b, c,
  output y
);
  wire w1, w2;
  and (w1, a, b);
  or (w2, w1, c);
  not (y, w2);
endmodule
`.trim();

console.log('\nüîß Running Logic Optimization (Area)...');
const logicOptResult = runSynthesis({
  algorithm: SynthesisAlgorithm.LOGIC_OPTIMIZATION,
  netlist,
  targetLibrary: 'std_cell_lib',
  optimizationLevel: 'area',
  clockPeriod: 10,
});
console.log(`‚úÖ Success: ${logicOptResult.success}`);
console.log(`üö™ Gate Count: ${logicOptResult.gateCount}`);
console.log(`üìè Area: ${logicOptResult.area}`);
console.log(`‚ö° Power: ${logicOptResult.power.toFixed(2)} mW`);
console.log(`‚è∞ Critical Path Delay: ${logicOptResult.criticalPathDelay.toFixed(2)} ns`);
console.log(`‚è±Ô∏è  Runtime: ${logicOptResult.runtime.toFixed(2)}ms`);

console.log('\nüéØ Running Technology Mapping...');
const techMapResult = runSynthesis({
  algorithm: SynthesisAlgorithm.TECHNOLOGY_MAPPING,
  netlist,
  targetLibrary: 'tsmc_65nm',
  optimizationLevel: 'timing',
  clockPeriod: 10,
});
console.log(`‚úÖ Success: ${techMapResult.success}`);
console.log(`üö™ Gate Count: ${techMapResult.gateCount}`);
console.log(`üìè Area: ${techMapResult.area}`);
console.log(`‚ö° Power: ${techMapResult.power.toFixed(2)} mW`);
console.log(`‚è±Ô∏è  Runtime: ${techMapResult.runtime.toFixed(2)}ms`);

// 5. TIMING ANALYSIS ALGORITHMS
console.log('\n\n‚è∞ 5. TIMING ANALYSIS ALGORITHMS');
console.log('-'.repeat(60));

const wires = mazeResult.wires;

console.log('\nüìä Running Static Timing Analysis...');
const staResult = runTiming({
  algorithm: TimingAlgorithm.STATIC_TIMING_ANALYSIS,
  netlist,
  clockPeriod: 10,
  cells: cellsWithPositions,
  wires,
});
console.log(`‚úÖ Success: ${staResult.success}`);
console.log(`üéØ Critical Path Length: ${staResult.criticalPath.length} cells`);
console.log(`üìà Max Delay: ${staResult.maxDelay.toFixed(2)} ns`);
console.log(`üìâ Min Delay: ${staResult.minDelay.toFixed(2)} ns`);
console.log(`‚è±Ô∏è  Slack Time: ${staResult.slackTime.toFixed(2)} ns`);
console.log(`üî¥ Setup Violations: ${staResult.setupViolations}`);
console.log(`üî¥ Hold Violations: ${staResult.holdViolations}`);
console.log(`‚è±Ô∏è  Runtime: ${staResult.runtime.toFixed(2)}ms`);

console.log('\nüîç Running Critical Path Analysis...');
const cpResult = runTiming({
  algorithm: TimingAlgorithm.CRITICAL_PATH,
  netlist,
  clockPeriod: 10,
  cells: cellsWithPositions,
  wires,
});
console.log(`‚úÖ Success: ${cpResult.success}`);
console.log(`üéØ Critical Path: ${cpResult.criticalPath.join(' ‚Üí ')}`);
console.log(`üìà Max Delay: ${cpResult.maxDelay.toFixed(2)} ns`);
console.log(`‚è±Ô∏è  Slack Time: ${cpResult.slackTime.toFixed(2)} ns`);
console.log(`‚è±Ô∏è  Runtime: ${cpResult.runtime.toFixed(2)}ms`);

// 6. POWER OPTIMIZATION ALGORITHMS
console.log('\n\nüîã 6. POWER OPTIMIZATION ALGORITHMS');
console.log('-'.repeat(60));

console.log('\n‚è∞ Running Clock Gating...');
const cgResult = runPower({
  algorithm: PowerAlgorithm.CLOCK_GATING,
  netlist,
  cells: cellsWithPositions,
  clockFrequency: 1000, // MHz
  voltage: 1.2, // V
  temperature: 25, // ¬∞C
});
console.log(`‚úÖ Success: ${cgResult.success}`);
console.log(`‚ö° Total Power: ${cgResult.totalPower.toFixed(4)} mW`);
console.log(`üîã Dynamic Power: ${cgResult.dynamicPower.toFixed(4)} mW`);
console.log(`üí§ Static Power: ${cgResult.staticPower.toFixed(4)} mW`);
console.log(`üìâ Power Reduction: ${cgResult.reduction.toFixed(2)}%`);
console.log(`‚è±Ô∏è  Runtime: ${cgResult.runtime.toFixed(2)}ms`);

console.log('\nüîΩ Running Voltage Scaling...');
const vsResult = runPower({
  algorithm: PowerAlgorithm.VOLTAGE_SCALING,
  netlist,
  cells: cellsWithPositions,
  clockFrequency: 1000,
  voltage: 1.2,
  temperature: 25,
});
console.log(`‚úÖ Success: ${vsResult.success}`);
console.log(`‚ö° Total Power: ${vsResult.totalPower.toFixed(4)} mW`);
console.log(`üìâ Power Reduction: ${vsResult.reduction.toFixed(2)}%`);
console.log(`‚è±Ô∏è  Runtime: ${vsResult.runtime.toFixed(2)}ms`);

console.log('\nüîå Running Power Gating...');
const pgResult = runPower({
  algorithm: PowerAlgorithm.POWER_GATING,
  netlist,
  cells: cellsWithPositions,
  clockFrequency: 1000,
  voltage: 1.2,
  temperature: 25,
});
console.log(`‚úÖ Success: ${pgResult.success}`);
console.log(`‚ö° Total Power: ${pgResult.totalPower.toFixed(4)} mW`);
console.log(`üí§ Leakage Power: ${pgResult.leakagePower.toFixed(4)} mW`);
console.log(`üìâ Power Reduction: ${pgResult.reduction.toFixed(2)}%`);
console.log(`‚è±Ô∏è  Runtime: ${pgResult.runtime.toFixed(2)}ms`);

// Summary
console.log('\n\n' + '='.repeat(60));
console.log('üìä SUMMARY - ALL ALGORITHMS EXECUTED SUCCESSFULLY!');
console.log('='.repeat(60));
console.log(`
‚úÖ 3 Placement algorithms
‚úÖ 3 Routing algorithms
‚úÖ 2 Floorplanning algorithms
‚úÖ 2 Synthesis algorithms
‚úÖ 2 Timing analysis algorithms
‚úÖ 3 Power optimization algorithms

Total: 15 chip design algorithms demonstrated!
`);
